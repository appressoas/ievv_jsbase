<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">source/html/CleanHtml.js | ievv_jsbase API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/SignalHandlerSingleton.js~ReceivedSignalInfo.html">ReceivedSignalInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/SignalHandlerSingleton.js~SentSignalInfo.html">SentSignalInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/SignalHandlerSingleton.js~SignalHandlerSingleton.html">SignalHandlerSingleton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeCustomError">makeCustomError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DuplicateReceiverNameForSignal">DuplicateReceiverNameForSignal</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">__testhelpers__</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/__testhelpers__/XMLHttpRequestMock.js~XMLHttpRequestMock.html">XMLHttpRequestMock</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">dom</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/DOMReplace.js~DOMReplace.html">DOMReplace</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/DOMReplaceFromUrl.js~DOMReplaceFromUrl.html">DOMReplaceFromUrl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/DOMReplaceWithSameElementFromUrl.js~DOMReplaceWithSameElementFromUrl.html">DOMReplaceWithSameElementFromUrl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/HtmlParser.js~HtmlParser.html">HtmlParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/ScriptLoaderSingleton.js~Script.html">Script</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/dom/ScriptLoaderSingleton.js~ScriptLoaderSingleton.html">ScriptLoaderSingleton</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">html</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~CleanHtml.html">CleanHtml</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~CleanHtmlOptions.html">CleanHtmlOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~CleanHtmlParser.html">CleanHtmlParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~CleanerNode.html">CleanerNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~FlatListCleanerNode.html">FlatListCleanerNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/html/CleanHtml.js~NoTextCleanerNode.html">NoTextCleanerNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-attributeObjectToHtml">attributeObjectToHtml</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-escapeAttributeValue">escapeAttributeValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInlineTag">isInlineTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSelfClosingTag">isSelfClosingTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeHtmlEndTag">makeHtmlEndTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeHtmlStartTag">makeHtmlStartTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PasteMarkerNotSetError">PasteMarkerNotSetError</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">http</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpCookies.js~HttpCookies.html">HttpCookies</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpDjangoFileRequest.js~HttpDjangoFileRequest.html">HttpDjangoFileRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpDjangoJsonRequest.js~HttpDjangoJsonRequest.html">HttpDjangoJsonRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpFileRequest.js~HttpFileRequest.html">HttpFileRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpFileResponse.js~HttpFileResponse.html">HttpFileResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpJsonRequest.js~JsonHttpRequest.html">JsonHttpRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpJsonResponse.js~HttpJsonResponse.html">HttpJsonResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpRequest.js~HttpRequest.html">HttpRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/HttpResponse.js~HttpResponse.html">HttpResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/QueryString.js~QueryString.html">QueryString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/http/UrlParser.js~UrlParser.html">UrlParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HttpCookieNotFoundError">HttpCookieNotFoundError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HttpResponseError">HttpResponseError</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">log</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/log/AbstractLogger.js~AbstractLogger.html">AbstractLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/log/Logger.js~Logger.html">Logger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/log/LoggerSingleton.js~LoggerSingleton.html">LoggerSingleton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/log/loglevel.js~LogLevels.html">LogLevels</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">polyfill</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-elementRemovePolyfill">elementRemovePolyfill</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/utils/ObjectManager.js~ObjectManager.html">ObjectManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/utils/PrettyFormat.js~PrettyFormat.html">PrettyFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/utils/TypeConvert.js~TypeConvert.html">TypeConvert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFileExtension">getFileExtension</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-onDocumentReady">onDocumentReady</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ensureMapHasDataInReduxStore">ensureMapHasDataInReduxStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getObjectFromReduxMapOrNullIfLoading">getObjectFromReduxMapOrNullIfLoading</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getValuesFromTypeMappedReduxMap">getValuesFromTypeMappedReduxMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeApiDataMapDeleted">makeApiDataMapDeleted</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeApiDataMapError">makeApiDataMapError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeApiDataMapIsLoading">makeApiDataMapIsLoading</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeApiDataMapNewData">makeApiDataMapNewData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeImmutableOrderedMapFromValueArray">makeImmutableOrderedMapFromValueArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeTypeMappedReduxMapFromApiData">makeTypeMappedReduxMapFromApiData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-typeDetect">typeDetect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TYPE_MAPPED_REDUX_MAP_DEFAULT_KEY">TYPE_MAPPED_REDUX_MAP_DEFAULT_KEY</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">widget</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/widget/AbstractWidget.js~AbstractWidget.html">AbstractWidget</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/source/widget/WidgetRegistrySingleton.js~WidgetRegistrySingleton.html">WidgetRegistrySingleton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ElementHasNoWidgetInstanceIdError">ElementHasNoWidgetInstanceIdError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ElementIsNotInitializedAsWidget">ElementIsNotInitializedAsWidget</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ElementIsNotWidgetError">ElementIsNotWidgetError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-InvalidWidgetAliasError">InvalidWidgetAliasError</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">source/html/CleanHtml.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import htmlparser from &quot;htmlparser2&quot;;
import {makeHtmlStartTag, makeHtmlEndTag, isInlineTag} from &quot;./utils&quot;;
import TypeConvert from &quot;../utils/TypeConvert&quot;;
import ObjectManager from &quot;../utils/ObjectManager&quot;;
import typeDetect from &quot;../utils/typeDetect&quot;;
import {PasteMarkerNotSetError} from &quot;./CleanHtmlErrors&quot;;


export class CleanerNode {
    constructor(options, parentNode, rootNode, preservePasteMarker, tagName, attributes={}) {
        this.pasteMarkerAttribute = &apos;data-ievv-paste-marker&apos;;
        this.preservePasteMarker = preservePasteMarker;
        this.pasteMarkerNode = null;
        this.rootNode = rootNode ? rootNode : this;
        this._inlineWrapperNode = null;
        this.options = options;
        this.parentNode = parentNode;
        this.originalTagName = tagName;
        this.originalAttributes = attributes;
        this.tagName = this.cleanTagName();
        this.attributes = this.cleanAttributes();
        this.children = [];
        this.pasteLevels = {
            root: 0,
            block: 1,
            inline: 2
        };
    }

    getPasteLevel() {
        if (this.isRootNode()) {
            return this.pasteLevels.root;
        }
        if (isInlineTag(this.tagName)) {
            return this.pasteLevels.inline;
        }
        return this.pasteLevels.block;
    }

    getPasteMarkerLevel() {
        return this.rootNode.pasteMarkerNode.parentNode.getPasteLevel();
    }

    getDeepestPasteLevelInTree() {
        let pasteLevel = this.getPasteLevel();
        for (let child of this.children) {
            if (pasteLevel == this.pasteLevels.inline) {
                return pasteLevel; // Returning because already at deepest possible level.. no need to iterate further..
            }
            if (typeDetect(child) == &apos;object&apos;) {
                const childPasteLevel = child.getDeepestPasteLevelInTree();
                if (childPasteLevel &gt; pasteLevel) {
                    pasteLevel = childPasteLevel;
                }
            }
        }
        return pasteLevel;
    }

    getBlockNodeForNode(node) {
      if (node.tagName != null &amp;&amp; !isInlineTag(node.tagName)) {
        return [true, node.tagName];
      }
      if (!node.isRootNode()) {
        return this.getBlockNodeForNode(node.parentNode);
      }
      return [false, null];
    }

    checkIfNodeIsJustStringAndExtractString(node) {
        if (typeDetect(node) == &apos;string&apos;) {
            return [true, node];
        }
        if (node.tagName == null &amp;&amp; node.children.length == 1) {
            return this.checkIfNodeIsJustStringAndExtractString(node.children[0]);
        }

        const [pasteMarkerInBlockTag, pasteMarkerBlockTag] = this.getBlockNodeForNode(this.rootNode.pasteMarkerNode);
        if (pasteMarkerInBlockTag &amp;&amp; pasteMarkerBlockTag == node.tagName &amp;&amp; node.children.length == 1) {
            return this.checkIfNodeIsJustStringAndExtractString(node.children[0]);
        }
        return [false, null];
    }

    insertNodeAtPasteMarker(node) {
        if (!this.rootNode.pasteMarkerNode) {
            throw new PasteMarkerNotSetError(&quot;Cannot insert node at pasteMarker - aborting insertion&quot;);
        }
        let [isStringNode, stringValue] = this.checkIfNodeIsJustStringAndExtractString(node);
        if (isStringNode) {
            // console.log(&quot;This node is just a string: &quot;, node);
            this.rootNode.pasteMarkerNode.parentNode.addChildNodeAtIndex(
                this.rootNode.pasteMarkerNode.getParentChildListIndex(), stringValue);
            return;
        }
        // console.log(&quot;This node is not a string: &quot;, node);
        // console.log(&quot;Got rootNode: &quot;, this.rootNode);
        const pasteLevelOfNewNode = node.getDeepestPasteLevelInTree();
        while (this.getPasteMarkerLevel() &gt;= pasteLevelOfNewNode) {
           this.splitAtPasteMarker();
        }

        node.parentNode = this.rootNode.pasteMarkerNode.parentNode;
        this.rootNode.pasteMarkerNode.parentNode.addChildNodeAtIndex(
            this.rootNode.pasteMarkerNode.getParentChildListIndex(), node);
        const [newMarkerParent, newMarkerIndex] = node.getLastPositionInNodeTree();
        this.movePasteMarkerTo(newMarkerParent, newMarkerIndex+1);
    }

    getLastPositionInNodeTree() {
        let parentNode = null, currentNode = this.rootNode;
        while (currentNode.children.length &gt; 0 &amp;&amp;
               typeDetect(currentNode.children[currentNode.children.length-1]) == &apos;object&apos;) {
            currentNode = currentNode.children[currentNode.children.length-1];
        }
        return [currentNode, currentNode.children.length-1];
    }

    splitAtPasteMarker() {
        if (!this.rootNode.pasteMarkerNode) {
            throw new Error(&quot;Cannot split at pasteMarker! pasteMarker is not set!&quot;);
        }
        if (this.rootNode.pasteMarkerNode.parentNode.isRootNode()) {
            throw new Error(&quot;Cannot split at pasteMarker! pasteMarker is placed at root!&quot;);
        }
        this.rootNode.pasteMarkerNode.splitParentAfterMe();
        this.movePasteMarkerTo(
            this.rootNode.pasteMarkerNode.parentNode.parentNode,
            this.rootNode.pasteMarkerNode.parentNode.getParentChildListIndex());
    }

    movePasteMarkerTo(node, index) {
        const previousParent = this.rootNode.pasteMarkerNode.parentNode;
        const previousParentIndex = this.rootNode.pasteMarkerNode.getParentChildListIndex();
        previousParent.children.splice(previousParentIndex, 1);
        this.rootNode.pasteMarkerNode.parentNode = node;
        node.addChildNodeAtIndex(index, this.rootNode.pasteMarkerNode);
    }

    getParentChildListIndex() {
        if (!this.parentNode) {
            throw new Error(&quot;Cannot get parentChildListIndex. Has no parent.&quot;);
        }
        return this.parentNode.children.indexOf(this);
    }

    splitAfterChildIndex(index) {
        if (index &gt;= this.children.length) {
            throw new Error(`Cannot split children at index ${index}, children.length: ${this.children.length}`);
        }

        const newSiblingNode = new CleanerNode(
          this.options, this.parentNode, this.rootNode,
          this.preservePasteMarker, this.tagName, this.attributes);
        newSiblingNode.children = this.children.slice(index);
        for (let child of newSiblingNode.children) {
            if (typeDetect(child) == &apos;object&apos;) {
                child.parentNode = newSiblingNode;
            }
        }
        this.children = this.children.slice(0, index);
        this.parentNode.addChildNodeAtIndex(this.getParentChildListIndex()+1, newSiblingNode);
    }

    splitParentAfterMe() {
        this.parentNode.splitAfterChildIndex(this.getParentChildListIndex());
    }

    addChildNodeAtIndex(index, node) {
        this.children.splice(index, 0, node);
    }

    getClosestParentWithTagName(tagName) {
        if(this.parentNode == null || this.parentNode.tagName == null) {
            return null;
        }
        if(this.parentNode.tagName == tagName) {
            return this.parentNode;
        } else {
            return this.parentNode.getClosestParentWithTagName(tagName);
        }
    }

    transformTagName() {
        if(this.originalTagName != null &amp;&amp; this.options.transformTagsMap.has(this.originalTagName)) {
            return this.options.transformTagsMap.get(this.originalTagName);
        }
        return this.originalTagName;
    }

    cleanTagName() {
        const tagName = this.transformTagName();
        if((tagName != null &amp;&amp; this.options.allowedTagsSet.has(tagName)) || this.isSpecialNode()) {
            return tagName;
        }
        return null;
    }

    cleanAttributes() {
        const cleanedAttributes = {};
        for(let attributeName of Object.keys(this.originalAttributes)) {
            if(this.options.isAllowedAttributeForTagName(this.tagName, attributeName) || this.isSpecialNode()) {
                cleanedAttributes[attributeName] = this.originalAttributes[attributeName];
            }
        }
        return cleanedAttributes;
    }

    shouldWrapStandaloneInlineTags() {
        return this.parentNode == null &amp;&amp; this.options.wrapStandaloneInlineTagName != null;
    }

    getStandaloneInlineTagWrapper() {
        if(this._inlineWrapperNode == null) {
            const node = this.makeChildNode(
                this.options.wrapStandaloneInlineTagName,
                this.options.wrapStandaloneInlineTagAttributes);
            this._inlineWrapperNode = node;
            this.children.push(node);
        }
        return this._inlineWrapperNode;
    }

    stopWrappingStandaloneInlineTags() {
        this._inlineWrapperNode = null;
    }

    addText(text) {
        if(this.shouldWrapStandaloneInlineTags()) {
            this.getStandaloneInlineTagWrapper().addText(text);
        } else {
            this.children.push(text);
        }
    }

    makeChildNode(tagName, attributes) {
        const cleanerNodeClass = this.options.getCleanerNodeClassForTagName(tagName);
        return new cleanerNodeClass(
            this.options, this, this.rootNode, this.preservePasteMarker,
            tagName, attributes);
    }

    isInlineTag() {
        return isInlineTag(this.tagName);
    }

    isRootNode() {
      return this.parentNode == null;
    }

    isPasteMarker() {
        if (this.originalAttributes.hasOwnProperty(this.pasteMarkerAttribute)) {
            if (this.isRootNode()) {
                throw new Error(&quot;the rootnode cannot be the paste marker-node!&quot;);
            }
            this.rootNode.setPasteMarkerNode(this);
            return true;
        }
        return false;
    }

    setPasteMarkerNode(node) {
      this.pasteMarkerNode = node;
    }

    /**
     * Special nodes are nodes like the paste-marker. If the cleaner is configured for it, these nodes should not be
     * cleaned or altered in any way.
     *
     * @returns {boolean} if true, the current node is a special node, as such, any attributes is legal and any tagname is legal.
     */
    isSpecialNode() {
        if (this.preservePasteMarker &amp;&amp; this.isPasteMarker()) {
            return true;
        }

        // Add if-tests for other special nodes here if any are added...

        return false;
    }

    addChildNode(node) {
        if(this.shouldWrapStandaloneInlineTags() &amp;&amp; node.isInlineTag()) {
            this.getStandaloneInlineTagWrapper().addChildNode(node);
        } else {
            this.stopWrappingStandaloneInlineTags();
            this.children.push(node);
        }
    }

    addChildNodeFromTag(tagName, attributes) {
        const node = this.makeChildNode(tagName, attributes);
        this.addChildNode(node);
        return node;
    }

    shouldRenderTag() {
        if (this.isSpecialNode()) {
            return true;
        }
        if(this.tagName == null) {
            return false;
        }
        const closestParentNodeWithSameTag = this.getClosestParentWithTagName(this.tagName);
        if(closestParentNodeWithSameTag == null) {
            return true;
        }
        return this.options.allowNestedWithinSameTagSet.has(this.tagName);
    }

    makeStartTag() {
        if(this.shouldRenderTag()) {
            return makeHtmlStartTag(this.tagName, this.attributes);
        }
        return &apos;&apos;;
    }

    makeEndTag() {
        if(this.shouldRenderTag()) {
            return makeHtmlEndTag(this.tagName);
        }
        return &apos;&apos;;
    }

    childrenToHtml() {
        let html = &apos;&apos;;
        for(let child of this.children) {
            if(typeof child == &apos;string&apos;) {
                html += child;
            } else {
                html += child.toHtml();
            }
        }
        return html;
    }

    toHtml() {
        let html = `${this.makeStartTag()}${this.childrenToHtml()}${this.makeEndTag()}`;
        if (ObjectManager.validate(this.options, &apos;normalizeEmptyTags&apos;)) {
            const emptyTagHtml = `&lt;${this.tagName}&gt;&lt;/${this.tagName}&gt;`;
            if(html == emptyTagHtml) {
                if (ObjectManager.validate(this.options.normalizeEmptyTags, &apos;fill&apos;, this.tagName)) {
                    const textToFillEmptyTag = this.options.normalizeEmptyTags.fill[this.tagName];
                    return `&lt;${this.tagName}&gt;${textToFillEmptyTag}&lt;/${this.tagName}&gt;`;
                }
                if (ObjectManager.validate(this.options.normalizeEmptyTags, &apos;remove&apos;)) {
                    if (this.options.normalizeEmptyTags.remove.includes(this.tagName)) {
                        return &apos;&apos;;
                    }
                }
            }
        }

        return html;
    }

    toString() {
        return this.toHtml();
    }
}


// Should be the default for nodes that can not contain
// text as a direct child, such as UL, OL, TABLE, ...
// and all the self-closing tags.
export class NoTextCleanerNode extends CleanerNode {
    addText(text) {}
}


export class FlatListCleanerNode extends NoTextCleanerNode {
    shouldRenderTag() {
        if(this.tagName == null) {
            return false;
        }
        const closestUlParentNode = this.getClosestParentWithTagName(this.tagName);
        return closestUlParentNode == null;
    }

    addChildNode(node) {
        const closestListParentNode = this.getClosestParentWithTagName(this.tagName);
        if(closestListParentNode == null) {
            super.addChildNode(node);
        } else {
            closestListParentNode.addChildNode(node);
        }
    }
}


/*
Handle paste:

    &lt;p&gt;Hello PASTEHERE&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Item PASTEHERE&lt;/li&gt;
    &lt;/ul&gt;

Handle force single parent element (ul).
Handle &amp;nbsp; (should be removed)

2 options:
- Clean everything after paste, and handle invalid nesting in the cleaner.
- Know where we are cleaning.

*/
export class CleanHtmlParser {
    constructor(html, options, preservePasteMarker) {
        this.options = options;
        this.preservePasteMarker = preservePasteMarker;
        this._parse(html);
        if(this._isWrappingStandaloneInline) {
            this.endWrappingStandaloneInline();
        }
    }

    _parse(html) {
        this._rootNode = new this.options.rootCleanerNodeClass(
            this.options,
            null,  // parentNode
            null,  // rootNode
            this.preservePasteMarker,
            this.options.rootCleanerNodeTagName,
            this.options.rootCleanerNodeAttributes);
        this._currentNode = this._rootNode;
        const parser = new htmlparser.Parser({
            onopentag: (...args) =&gt; {
                this.onOpenTag(...args);
            },
            ontext: (...args) =&gt; {
                this.onText(...args);
            },
            onclosetag: (...args) =&gt; {
                this.onCloseTag(...args);
            }
        }, {decodeEntities: true});
        parser.write(html);
        parser.end();
    }

    onOpenTag(tagName, attributes) {
        const node = this._currentNode.addChildNodeFromTag(tagName, attributes);
        // console.log(`${tagName}: ${node.toString()}`);
        this._currentNode = node;
    }

    onText(text) {
        this._currentNode.addText(text);
    }

    onCloseTag(tagName) {
        this._currentNode = this._currentNode.parentNode;
    }

    get rootNode() {
        return this._rootNode;
    }
}


export class CleanHtmlOptions {
    constructor() {
        this._allowedTagsSet = new Set();
        this._allowedAttributesMap = new Map();
        this._allowNestedWithinSameTagSet = new Set();
        this._transformTagsMap = new Map();
        this.defaultCleanerNodeClass = CleanerNode;
        this.rootCleanerNodeClass = CleanerNode;
        this.rootCleanerNodeTagName = null;
        this.rootCleanerNodeAttributes = {};
        this._tagNameToCleanerNodeClassMap = new Map();
        this.wrapStandaloneInlineTagName = null;
        this.wrapStandaloneInlineTagAttributes = {};
        this.normalizeEmptyTags = null;
    }

    get allowedTagsSet() {
        return this._allowedTagsSet;
    }

    set allowedTagsSet(allowedTagsSet) {
        this._allowedTagsSet = TypeConvert.toSet(allowedTagsSet);
    }


    get allowedAttributesMap() {
        return this._allowedAttributesMap;
    }

    set allowedAttributesMap(allowedAttributesMap) {
        this._allowedAttributesMap = TypeConvert.toMapOfSets(allowedAttributesMap);
    }

    isAllowedAttributeForTagName(tagName, attributeName) {
        if(this._allowedAttributesMap.has(tagName)) {
            return this._allowedAttributesMap.get(tagName).has(attributeName);
        }
        return false;
    }


    set transformTagsMap(transformTagsMap) {
        this._transformTagsMap = TypeConvert.toMap(transformTagsMap);
    }

    get transformTagsMap() {
        return this._transformTagsMap;
    }


    get allowNestedWithinSameTagSet() {
        return this._allowNestedWithinSameTagSet;
    }

    set allowNestedWithinSameTagSet(allowNestedWithinSameTagSet) {
        this._allowNestedWithinSameTagSet = TypeConvert.toSet(allowNestedWithinSameTagSet);
    }


    set tagNameToCleanerNodeClassMap(tagNameToCleanerNodeClassMap) {
        this._tagNameToCleanerNodeClassMap = TypeConvert.toMap(tagNameToCleanerNodeClassMap);
    }

    get tagNameToCleanerNodeClassMap() {
        return this._tagNameToCleanerNodeClassMap;
    }

    getCleanerNodeClassForTagName(tagName) {
        if(this._tagNameToCleanerNodeClassMap.has(tagName)) {
            return this._tagNameToCleanerNodeClassMap.get(tagName);
        } else {
            return this.defaultCleanerNodeClass;
        }
    }

    setCleanerNodeClassForTagName(tagName, cleanerNodeClass) {
        this._tagNameToCleanerNodeClassMap.set(tagName, cleanerNodeClass);
    }

    // updateFromObject(optionsObject) {
    //     if(typeof optionsObject.allowedTagsSet != &apos;undefined&apos;) {
    //         this.allowedTagsSet = optionsObject.allowedTagsSet;
    //     }
    //     if(typeof optionsObject.allowedAttributesMap != &apos;undefined&apos;) {
    //         this.allowedAttributesMap = optionsObject.allowedAttributesMap;
    //     }
    //     if(typeof optionsObject.transformTagsMap != &apos;undefined&apos;) {
    //         this.transformTagsMap = optionsObject.transformTagsMap;
    //     }
    // }
}


/**
 * HTML cleaner with extra post cleaning that makes it
 * suitable for cleaning input typed and pasted into
 * contenteditable editors.
 */
export default class CleanHtml {
    constructor() {
        this.options = new CleanHtmlOptions();
    }

    /**
     * Called at the beginning of {@link CleanHtml#clean}
     * before performing the default cleaning.
     *
     * Subclasses can override this to perform additional
     * cleaning pre-cleaning.
     *
     * @param {string} html The HTML to pre-clean.
     * @returns {string} The pre-cleaned HTML. Defaults to returning
     *    the provided ``html`` unchanged.
     */
    preClean(html) {
        return html;
    }


    /**
     * Called at the end of {@link CleanHtml#clean}
     * after performing the default cleaning.
     *
     * Subclasses can override this to perform additional
     * cleaning post-cleaning.
     *
     * @param {string} html The HTML to post-clean.
     * @returns {string} The cleaned HTML. Defaults to returning
     *    the provided ``html`` unchanged.
     */
    postClean(html) {
        return html;
    }

    _getCleanedTree(html, preservePasteMarker) {
        return new CleanHtmlParser(html, this.options, preservePasteMarker);
    }

    _clean(html, preservePasteMarker) {
        return this._getCleanedTree(html, preservePasteMarker).rootNode.toHtml();
    }

    /**
     * Clean the provided html.
     *
     * @param {string} html The HTML to clean.
     * @param preservePasteMarker {boolean} if true, leave the tag with `data-ievv-paste-marker` attribute.
     * @returns {string} The cleaned HTML.
     */
    clean(html, preservePasteMarker=false) {
        let cleanedHtml = this.preClean(html);
        cleanedHtml = this._clean(cleanedHtml, preservePasteMarker);
        cleanedHtml = this.postClean(cleanedHtml);
        return cleanedHtml;
    }

    /**
     * This function takes two html-blobs, `originalHtml` is the original text, `pastedHtml` is text to be inserted in
     * `originalHtml`.
     * The original html-blob should contain a &apos;marker-element&apos; determining where to paste the given `pastedHtml`. This
     * marker element should have the data-attribute `data-ievv-paste-marker`. If multiple marker-elements are present,
     * an error will be logged, and `pastedHtml` will be inserted at the first one.
     *
     * Note: result from these examples will be cleaned once more using default cleaner, so if the cleaner is configured
     * to wrap standalone text the standalone text in e.g. example 1 would be wrapped in some block-level tag before returning.
     *
     * @example &lt;caption&gt;1 - pasting unformatted text without marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am some text&lt;/p&gt;
     * pastedHtml: awesome
     * result: &lt;p&gt;Hello world! I am some text&lt;/p&gt;awesome
     *
     * @example &lt;caption&gt;2 - pasting formatted text without marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am some text&lt;/p&gt;
     * pastedHtml: &lt;strong&gt;awesome&lt;/strong&gt;
     * result: &lt;p&gt;Hello world! I am some text&lt;/p&gt;&lt;strong&gt;awesome&lt;/strong&gt;
     *
     * @example &lt;caption&gt;3 - pasting unformatted text with marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am some &lt;span data-ievv-paste-marker&gt;&lt;/span&gt;text&lt;/p&gt;
     * pastedHtml: awesome
     * result: &lt;p&gt;Hello world! I am some awesome&lt;span data-ievv-paste-marker&gt;&lt;/span&gt;text&lt;/p&gt;
     *
     * @example &lt;caption&gt;4 - pasting formatted text with marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am some &lt;span data-ievv-paste-marker&gt;&lt;/span&gt;text&lt;/p&gt;
     * pastedHtml: &lt;strong&gt;awesome&lt;/strong&gt;
     * result: &lt;p&gt;Hello world! I am some &lt;strong&gt;awesome&lt;span data-ievv-paste-marker&gt;&lt;/span&gt;&lt;/strong&gt;text&lt;/p&gt;
     *
     * @example &lt;caption&gt;5 - pasting block tag with marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am some &lt;span data-ievv-paste-marker&gt;&lt;/span&gt;text&lt;/p&gt;
     * pastedHtml: &lt;p&gt;awesome&lt;/p&gt;
     * result: &lt;p&gt;Hello world! I am some &lt;/p&gt;
     *         &lt;p&gt;awesome&lt;span data-ievv-paste-marker&gt;&lt;/span&gt;&lt;/p&gt;
     *         &lt;p&gt;text&lt;/p&gt;
     *
     * @example &lt;caption&gt;6 - pasting formatted text in formatting with marker:&lt;/caption&gt;
     * originalHtml: &lt;p&gt;Hello world! I am &lt;strong&gt;some &lt;span data-ievv-paste-marker&gt;&lt;/span&gt;text&lt;/strong&gt;&lt;/p&gt;
     * pastedHtml: &lt;strong&gt;awesome&lt;/strong&gt;
     * result: &lt;p&gt;Hello world! I am &lt;strong&gt;some &lt;/strong&gt;&lt;strong&gt;awesome&lt;span data-ievv-paste-marker&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;text&lt;/strong&gt;&lt;/p&gt;
     *
     * @param originalHtml
     * @param pastedHtml
     */
    paste(originalHtml, pastedHtml) {
        const cleanedPastedTree = this._getCleanedTree(pastedHtml);
        const cleanedOriginalTree = this._getCleanedTree(originalHtml, true);

        // console.log(`Running paste.\n\nCleaned original tree: ${cleanedOriginalTree.rootNode.toHtml()}\n\ncleanedPastedTree: ${cleanedPastedTree.rootNode.toHtml()}`);
        // console.log(`cleanedOriginalTree.rootNode: `, cleanedOriginalTree.rootNode);
        // console.log(`cleanedPastedTree.rootNode: `, cleanedPastedTree.rootNode);

        try {
            cleanedOriginalTree.rootNode.insertNodeAtPasteMarker(cleanedPastedTree.rootNode);
        } catch(e) {
            if (e instanceof PasteMarkerNotSetError) {
                const cleanedOriginalHtml = cleanedOriginalTree.rootNode.toHtml();
                const cleanedPastedHtml = cleanedPastedTree.rootNode.toHtml();
                return this.clean(`${cleanedOriginalHtml}${cleanedPastedHtml}`, true);
            } else {
                throw e;
            }
        }

        return this.clean(cleanedOriginalTree.rootNode.toHtml(), true);
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
